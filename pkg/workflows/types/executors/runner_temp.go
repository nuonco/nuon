package executors

//  THIS FILE IS GENERATED. DO NOT EDIT. EDITING IS FUTILE.
// 
//  Generated by:
//      mono/pkg/bins/temporal-gen
//  Using jennies:
//      WorkflowJenny
// 
//  Run 'go generate' to regenerate this file.
// 
//  slack @sdboyer about any problems in this file, we'll get em fixed in a jiffy

import (
	"time"
	"fmt"

	enumsv1 "go.temporal.io/api/enums/v1"
	"go.temporal.io/sdk/workflow"
)

// AwaitProvisionIAM executes [ProvisionIAM] as a Temporal workflow, waits for the future to complete, then returns the error, if any.
func AwaitProvisionRunner(ctx workflow.Context, workflowID string, req *ProvisionRunnerRequest) (*ProvisionRunnerResponse, error){
	cwo := workflow.ChildWorkflowOptions{
		TaskQueue:                "executors",
		WorkflowID:               workflowID,
		WorkflowExecutionTimeout: 10 * time.Minute,
		WorkflowTaskTimeout:      1 * time.Minute,
		WorkflowIDReusePolicy:    enumsv1.WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING,
		WaitForCancellation:      false,
	}
	ctx = workflow.WithChildOptions(ctx, cwo)

	// The func pointer being passed here is not used for execution. Temporal uses it as the
	// key for a name lookup against its activity registry, so that it knows what activity function
	// to actually call when the workflow is ready to be executed.
	var resp ProvisionRunnerResponse
	if err := workflow.ExecuteChildWorkflow(ctx, ProvisionRunner, req).Get(ctx, &resp); err != nil {
    return nil, fmt.Errorf("unable to execute child workflow: %w", err)
  }

  return &resp,nil
}

// AwaitDeprovisionIAM executes [DeprovisionIAM] as a Temporal workflow, waits for the future to complete, then returns the 
// error, if any.
func AwaitDeprovisionRunner(ctx workflow.Context, workflowID string, req *DeprovisionRunnerRequest) (*DeprovisionRunnerResponse, error){
	cwo := workflow.ChildWorkflowOptions{
		TaskQueue:                "executors",
		WorkflowID:               workflowID,
		WorkflowExecutionTimeout: 10 * time.Minute,
		WorkflowTaskTimeout:      1 * time.Minute,
		WorkflowIDReusePolicy:    enumsv1.WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING,
		WaitForCancellation:      false,
	}
	ctx = workflow.WithChildOptions(ctx, cwo)

	// The func pointer being passed here is not used for execution. Temporal uses it as the
	// key for a name lookup against its activity registry, so that it knows what activity function
	// to actually call when the workflow is ready to be executed.
	var resp DeprovisionRunnerResponse
	if err := workflow.ExecuteChildWorkflow(ctx, DeprovisionRunner, req).Get(ctx, &resp); err != nil {
    return nil, fmt.Errorf("unable to execute child workflow: %w", err)
  }

  return &resp,nil
}
